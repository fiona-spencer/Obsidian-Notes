- In a uniprogramming system, main memory is divided into 2 parts
	- OS
		- Resident monitor
		- Kernel
	- Executing programs
- In a multiprogramming system, the "user" part of the memory is further divided to accommodate multiple processes
- The task of subdivision is carries out dynamically by the OS and is known as memory management

# <font style="color:#96DED1"> 7.1 - Memory Management Requirements</font>

---
- Requirements of Memory Management
	- Relocation
	- Protection
	- Sharing
	- Location organization
	- Physical organization

![[Pasted image 20250404122723.png|500]]


# Relocation
- In a multiprogramming system, the available main memory is shared among a number of processes
- Once a program is swapped out to disk, it is relocated to a different area of memory
- The process image occupies a contiguous region of main memory
- The OS will need to know the location of process control information and of the execution stack, as well as the entry point to begin execution of the process for this processes
- The processor must deal with memory references within the program
- Branch instructions contain an address to reference the instruction to be executed next
- Data reference instructions contain the address of the byte or word of data referenced
- The processor hardware and OS software must translate the memory reference into a physical memory address

![[Pasted image 20250404123145.png|400]]


# Protection
- Each process should be protected against unwanted interference by other processes, whether accidental or intentional
- Programs in other processes should not be able to reference memory location in a process for reading or writing purposes without permission
- Most programming languages allows the dynamic calculation of address at run time
	- By computing an array subscript or a pointer into a data structure
- All memory references generated by a process must be checked at run time to ensure they refer only to the memory space allocated to that process
- A user process cannot access any portion of the OS
- Memory protection requirement must be satisfied by the processor (hardware) rather than the OS (software)

# Sharing
- Any protection mechanism must have the flexibility to allow several processes to access the same portion of main memory

# Logical Organization
- Main memory in a computer system is organized as a linear or one-dimensional address space, consisting of a sequence of bytes or words
- Secondary memory, at its physical level, is similarly organized
- Most programs are organized into modules, some of which are unmodified (read/execute only) and some of which contain data that may be modified
- Advantages
	- Modules can be written and compiled independently, while all references from one module to another resolved by the system at run time
	- With modest additional overhead, different degrees of protection (read/execute only) can be given to different modules
	- It is possible to introduce mechanisms by which modules can be shared among processes
- The tool that most readily satisfies these requirements is segmentation, which is one of the memory management techniques explored in this chapter

# Physical Organization
- Computer memory is organized into main and secondary memory
- Main memory provides fast access at relatively high cost
	- Volatile
- Secondary memory is slower and cheater
	- Permanent
- The main memory available for a program and its data may be insufficient
- Programmers must engage in overlaying, in which the program and data are organized in a way that various modules can be assigned the same region of memory, with a main program responsible for switching the modules in and out
- In a multiprogramming environment, the programmer does not know at the time of coding how must space will be available


# <font style="color:#96DED1"> 7.2 - Memory Partitioning</font>

---
- The principle operation of memory management is to bring processes into main memory for execution by the processor
- In almost all modern systems this involves virtual memory
- Virtual memory is based on the use of one or both of two techniques
	- Segmentation
	- Paging
- Partitioning has been used in various older OS

# Fixed Partitioning
- In most schemes of memory management, OS occupies some fixed portion of main memory
- The rest is available for processes
- The simplest scheme for managing this is to partition it into regions with fixed boundaries


_PARTITION SIZES_
- Make use of equal-size partitions
- Any process whose size is less than or equal to the partition size can be loaded into any available partition
- If all partitions are full, and no process is in the Ready or Running state, the OS can swap a process out of any of the partitions and load in another processes
- 2 Challenges with Equal-Size Partitions
	- A program may be too big to fit into a partition
	- Main memory utilization is extremely inefficient
	- Internal fragmentation is when there is wasted space internal to a partition due to a block of data loaded that is smaller than the partitions
- Partitions smaller than 8 Mbytes allow smaller programs to be accommodated with less internal fragmentation

![[Pasted image 20250404130837.png|600]]


_PLACEMENT ALGORITHM_
- With unequal-size partitions, there are two possible ways to assign processes to partitions
- The simplest way is to assign each process to the smallest partition within which it will fit
- A scheduling queue is needed for each partitions to hold swapped-out processes destined for that partition
- The advantage of this is processes are always assigned in such a way to minimize wasted memory
- Although this is not optimum from the point of view of the system as a whole

![[Pasted image 20250404131116.png|300]]

- With a single queue for all processes the smallest, available partition will hold the process
- If all partitions are used, then a swapping decision is made
- Unequal-size partitions provides a degree of flexibility to fixed. partitioning
- Fixed partitioning are simple and require minimal OS and overhead
- Disadvantage of fixed partitioning
	- The number of partitions specified at system generation time limits the number of active (not suspended) processes in the system
	- Small jobs will not utilized partition space efficiently


![[Pasted image 20250404131553.png|400]]


# Dynamic Partitioning
- To overcome the difficulties with fixed partitioning, an approach known as dynamic partitioning was developed
- Partitions are of variable length and number
- When a process is brought into main memory, it is allocated exactly as much memory as it requires and not more

- A 64 Mbytes of main memory, is shown
- Initially main memory is empty, except for the OS
- The first 3 processes are loaded in, starting where the OS ends
- This leaves a "hole" at the end of memory that is too small for a fourth process
- This method starts out will, but will eventually lead to a situation in which there are a lot of small holes in memory
- As time goes on, memory becomes more and more fragmented, and more memory utilization declines
- This is referred to as external fragmentation, indicating the memory that is external to all partitions becomes increasingly fragmented
- A technique to overcome external fragmentation is compaction
- The OS shifts the processes so that they are contiguous and all of the free memory is in one block
- It must be possible to move a program from one region to another in main memory, without invalidating the memory references in the program

![[Pasted image 20250404133048.png|400]]


_PLACEMENT ALGORITHM_
- When it is time to load or swap a process into main memory, and if there is more than one free block of memory of sufficient size, the OS must decide which free block to allocate
- 3 placement algorithms
	- Best-fit
	- First-fit
	- Next-fit
- Best-fit chooses the block that is closest in size to the request
- First-fit begins to scam memory from the beginning and chooses the first available block that is large enough
- Next-fit begins to scan memory from the last location of the last placement and chooses the next available block that is large enough

![[Pasted image 20250404133443.png|400]]

- The first-fit algorithm is not only the simplest but it is usually the best and fastest
- The next-fit tends to produce slightly worse results than the first-fit
- The best-fit will more frequently lead to an allocation from a free block at the end of memory
- The best-fit is usually the worst performer, because it looks for the smallest block that will satisfy the requirements, and guarantees that the small fragments left behind
- Main memory is quickly littered by blocked too small to satisfy memory allocation requests
- Memory compaction must be done more frequently than with the other algorithms



_REPLACEMENT ALGORITHM_
- In a multiprogramming system using dynamic partitioning, it is possible that main memory is blocks and there is insufficient memory
- To avoid wasting processor time waiting for an active process to become unblocked, the OS swaps one of the processes out of main memory

# Buddy System
- Both fixed and dynamic partitioning schemes have drawbacks
- A fixed partitioning scheme limits the number of active processes and may use space inefficiency if there is a poor match between available partition sizes and process sizes
- A dynamic partitioning scheme is more complex to maintain and includes the overhead of compaction
- In a buddy system, memory blocks are available of size $2^K$ words

![[Pasted image 20250404134216.png|100]]

$2^L$ = smallest size block that is allocated
$2^U$ = largest size block that is allocated, size of entire memory available for allocation

- The entire space available for allocation is treated as a single block of size $2^U$
- If requested of size s is made, then the entire block is allocated
- Otherwise, the block is split into two equal buddies of size $2^{U-1}$
- If the request is not allocated, one of the buddies is split in half again
- This process continues until the smallest block greater than or equal to $s$ is generated and allocated to the request

```c
void get_hold(int i){
	if (i == (U + 1)) <failure>;
	if (<i_list emptry>){
		get_hole(i + 1);
		<split hold into buddies>;
		<put buddies on i_list>;
	}
	<take first hold on i_list>;
}
```

![[Pasted image 20250404135919.png]]

- The initial block is 1 Mbytes
- The first request, A, is for 100 Kbytes, where 128K block is needed
- The initial block is divided into 512K, then 256K, then 128K
- B request 256K and is allocated
- When E is released, two 128K buddies are coalesced into 256K block, and is coalesced with its buddy to form a 512K block
- The binary tree representation of the buddy allocation immediately after the Release of B request
- The left nodes represent current partitioning of the memory
- If two buddies are leaf nodes, then at least one must be allocated
- The buddy system is a responsible compromise to overcome the disadvantages of both the fixed and variable partitioning schemes
- In contemporary OS, virtual memory based on paging and segmentation is superior

![[Pasted image 20250404140506.png|400]]



# Relocation
- When the fixed partition scheme is used, a process will always be assigned to the same partition
- A simple relocating loader is used
- When the process is first loaded, all relative memory references in the code are replaced by absolute main memory address, determined by the based address of the loaded process
- When a process image is first created, it is loaded into some partition of main memory
- Later, the process may be swapped out or in
- Locations referenced by a process are not fixed
- They will change each time a process is swapped or shifted
- A logical address is a reference to a memory location independent of the current assignment of data to memory
- A relative address is a particular example of logical address, in which the address is expressed as a location relative to some known point, usually a value in a process register
- A physical address, or absolute address, is an actual location in main memory
- programs that employ relative addresses in memory are loaded using dynamic run-time loading
- Memory references in the loaded process are relative to the origin of the program
- Hardware mechanism is needed for translating relative addresses to physical main memory addresses at the time of execution

![[Pasted image 20250404141033.png|500]]

- When a process is assigned to the Running state, a special processor register, called the base register, is loaded with the starting address in main memory
- There is also "bounds" register that indicates the ending location of the program
- These values must be set when the program is loaded into memory or when the process image is swapped in
- During the execution, relative addresses are encountered
- 2 steps
	- Value in the base register is added to the relative address to produce an absolute address
	- The resulting address is compared to the value in the bounds register
- Each process image is isolated by the contents of the base and bounds register, and is safe from unwanted access by other processes


# <font style="color:#96DED1"> 7.3 - Paging</font>

---

- Both unequal fixed-size and variable-size partitions are inefficient in the use of memory
- The former results in internal fragmentation, and the latter external fragmentation
- Main memory is partitioned into equal-fixed size chunks, known as pages, and are assigned to available chucks of memory, known as frames
- There is a fraction of the internal fragmentation, and no external fragmentation
- Process A, stored on disk, consists of four pages
- Process B, consisting of three pages, and process C, 4 pages are loaded
- B is suspended and is swapped out of main memory
- Process D is loaded in available frames

![[Pasted image 20250404153940.png|400]]
![[Pasted image 20250404154225.png|500]]


- A page table contains one entry for each page of the process, so the table is easily indexed by the page number
- Each page table entry contains the number of the frame in main memory, that holds the corresponding page
- OS maintains a single free-frame list of all the frames in main memory that are currently unoccupied and available for pages
- With paging, the partitions are rather small
- A program may occupy more than one partition, that may not be contiguous

![[Pasted image 20250404154254.png|600]]

- 16-bit addresses are used, and the page size is 1K = 1024 bytes
- The relative address is 1502
- An offset field of 10 bits is needed, leaving 6 bits for the page number
- A program can consists of a maximum of $2^6 = 64$ pages of size 1 K bytes each
- Consequences of using a page size that is a power of 2
	- The logical addressing scheme is transparent to the programmer, the assembler, and linker
	- Easy to implement a function in hardware to perform dynamic address translation at run time
- Steps for Address Translation
	- Extract the page number at the leftmost $n$ bits of the logical address
	- Use the page number as an index into the process page table to find the frame number, $k$
	- The starting physical address of frame is $k x 2_m$, and the physical address of the referenced byte is that number plus the offset

![[Pasted image 20250404154828.png|500]]

Local address => `0000 0101 1101 1110` = page #1
Offset 478 => `xxxx xx01 1101 1110`
Frame 6 => `000110`
Physical address is frame number 6, offset 478 => `0001 1001 1101 110`

# <font style="color:#96DED1"> 7.4 - Segmentation</font>

---
- A user program can be subdivided using segmentation, in which the program and its associated data are divided into a number of segments
- A logical address using segmentation consists of two parts
	- Segment number
	- Offset
- Segmentation is similar to dynamic partitioning
- In the absence of an overlay scheme or the use of virtual memory, all of a program's segments must be loaded into memory for execution
- Segmentation eliminates internal fragmentation, but has external fragmentation
- Segmentation is visible to the programmer and is provided as a convenience for organizing programs and data
- For modular programming, the program or data can be further broken down into multiple segments
- A consequence of unequal-size segments is that there is no simple relationship between logical addresses and physical addresses
- When a process enters the Running state, the address of its segment table is loaded into a special register used by the memory management hardware
- Steps for address translation
	- Extract the segment number at the leftmost $n$ buts of the logical address
	- Use the segment number as an index into the process segment table to find the starting physical address of the segment
	- Compare the offset, expressed in the rightmost $m$ bits
	- The desired physical address is the sum of the starting physical address of the segment plus the offset

Logical address => `0001 0010 1111 0000`
4-bit segment => `0001 xxx xxxx xxxx` = 1
12-bit offset => `xxx 0010 1111 0000` = 752
Starting physical address => `0010 0000 0100 0000`
Physical address => `0010 0000 0100 000` + `00101111000` = `0010 0011 0001 0000`

# <font style="color:#96DED1"> 7.5 - Summary</font>

---
- Memory management involved treating main memory as a resource to be allocated to and shard among a number of active processes
- The basic tool of memory management are paging and segmentation
- Paging divides each process into relatively small, fixed-size pages
- Segmentation provides the use of pieces of varying size


# <font style="color:#96DED1"> 7.6 - Key Terms, Review Questions, and Problems</font>

---

