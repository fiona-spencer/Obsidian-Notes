---

---
---

# Type System

# Type Checking

# Static vs Dynamic

# Static Type Checking

# Dynamic Type Checking

# Static vs Dynamic

# Untyped?

# Strong vs Weak

# Imprecision of Floating Point

# Infinite Integers

# Overflow




# ==RUST==

---

# Rust History

# Rust Features

# Rust and Safety

# Rust Non-Goals

# Variables

# Mutable Variables

# Constant/Global Variables

# Shadowing

# Shadowing vs Mut

# Data Types

# Scalar Types: Integers

# Integer Literals

# Scalar Types: Floating Point

# Numeric Operations

# Mixed Expressions

# Scalar Types: Booleans

# Scalar Types: Characters

# Types and Literals: Summary

# Compound Types: Tuples

# Accessing Elements

# Compound Types

# Array of Tuples

# Types and Literals: Summary

# Strings

# Functions

# Statements and Expression

# Scope Blocks as Expressions

# Return Value


---

# If/Else

# Boolean Conditions

# Looping

# Condition Looping: while

# Conditional Looping: for

# Ownership

# Reminder: Stack vs Heap

# Strings

# Heap Strings

# `clone()`

# Returning Ownership

# Ownership: Moving vs Borrowing

# Borrowing Rules

# Borrowing Rules: In Short

# Slices

# Slices, Arguments, Functions

# String Slices

# String Slice Type

# String Literals

# Rust Features

# Dangling References

# The Borrow Checker

# Generic Lifetimes

# Lifetime Annotation Syntax

# Consider

# Lifetime Considerations

# Lifetime Inference Rules

# Static Lifetime

---

# Reminder: Types and Literals

# Structure: Similar to C/C++

# Structures

# Structures: Accessing Fields

# Structures: As Return Values

# Structures: Parameter Shorthand

# Tuple Structures

# Structures, References, Lifetimes

# Methods vs Functions

# Enums

# Pattern Matching

# Rules: Match

# Nested Control

# Enum: Option

# Option

# Generic Types: Structs

# Generic Types: Struct Methods

# Generic Types: Enums

# mut

# Generic Types

# Traits

# Traits and Methods

# Custom Trait

# `#derive`

# Implement Display

# 
