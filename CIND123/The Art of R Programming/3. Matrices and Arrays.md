
- A _matrix_ is a vector with two additional attributes
	- Number of rows
	- Number of columns
- Arrays can be multi-dimensional consisting of rows, columns, and layers

# 3.1 - Creating Matrices

- Matrix row and column subscripts being with 1
- Upper-left corner of matrix `a` is denoted `a[1,1]`
- The internal storage of a matrix is column-major order
	- First column is stores, then the next

```R
> y <- matrix(c(1,2,3,4),nrow=2,ncol=2)
> y
[,1] [,2]
[1,] 1 3
[2,] 2 4
```

- R shows notation for rows and columns
	- `[rows,columns]`

```R
> y[,2]
[1] 3 4
```


- Another way to specify elements

```R
> y <- matrix(nrow=2,ncol=2)
> y[1,1] <- 1
> y[2,1] <- 2
> y[1,2] <- 3
> y[2,2] <- 4
> y
[,1] [,2]
[1,] 1 3
[2,] 2 4
```

- R needs to be given the matrix type, row, and column size
- To change to row-major order, use `byrow`
- This enables the input to change to be more suited for reading and data file organization

```R
> m <- matrix(c(1,2,3,4,5,6),nrow=2,byrow=T)
> m
[,1] [,2] [,3]
[1,] 1 2 3
[2,] 4 5 6
```

# 3.2 - General Matrix Operations

- Common operations
	- Linear algebra
	- Matrix indexing
	- Matrix filtering

## Performing Linear Algebra Operations on Matrices

- Linear algebra operations
	- Matrix multiplication
	- Matrix scalar multiplication
	- Matrix addition

```R
> y %*% y # mathematical matrix multiplication
[,1] [,2]
[1,] 7 15
[2,]10 22
> 3*y # mathematical multiplication of matrix by scalar
[,1] [,2]
[1,] 3 9
[2,] 6 12
> y+y # mathematical matrix addition
[,1] [,2]
[1,] 2 6
[2,] 4 8
```

## Matrix Indexing

- `z[,2:3]` returns all elements with columns 2 and 3, and any row number


```R
> z
[,1] [,2] [,3]
[1,] 1 1 1
[2,] 2 1 0
[3,] 3 0 1
[4,] 4 0 0
> z[,2:3]
[,1] [,2]
[1,] 1 1
[2,] 1 0
[3,] 0 1
[4,] 0 0
```

- Extracting rows

```R
> y
[,1] [,2]
[1,]11 12
[2,]21 22
[3,]31 32
> y[2:3,]
[,1] [,2]
[1,]21 22
[2,]31 32
> y[2:3,2]
[1] 22 32
```


- Assign values to sub-matrices

```R
> y
[,1] [,2]
[1,] 1 4
[2,] 2 5
[3,] 3 6
> y[c(1,3),] <- matrix(c(1,1,8,12),nrow=2)
> y
[,1] [,2]
[1,] 1 8
[2,] 2 5
[3,] 1 12
```

```R
> x <- matrix(nrow=3,ncol=3)
> y <- matrix(c(4,5,2,3),nrow=2)
> y
[,1] [,2]
[1,] 4 2
[2,] 5 3
> x[2:3,2:3] <- y
> x
[,1] [,2] [,3]
[1,] NA NA NA
[2,] NA 4 2
[3,] NA 5 3
```

- Negative subscripts are used to exclude elements

```R
> y
[,1] [,2]
[1,] 1 4
[2,] 2 5
[3,] 3 6
> y[-2,]
[,1] [,2]
[1,] 1 4
[2,] 3 6
```

## Extending Example: Image Manipulation

- Images files are matrices, since pixels are arranged in rows and columns
- For each pixel in grayscale, the intensity/brightness is stored
- For a colour image, three matrices are stored
- Use `pixmap` library to read an image

```R
> library(pixmap)
> mtrush1 <- read.pnm("mtrush1.pgm")
> mtrush1
Pixmap image
Type : pixmapGrey
Size : 194x259
Resolution : 1x1
Bounding box : 0 0 259 194
> plot(mtrush1)
> str(mtrush1)
Formal class 'pixmapGrey' [package "pixmap"] with 6 slots
..@ grey : num [1:194, 1:259] 0.278 0.263 0.239 0.212 0.192 ...
..@ channels: chr "grey"
..@ size : int [1:2] 194 259
...
```

- This matrix has 194 rows, and  259 columns
- An have a pixel intensity from 0 to 1
- Use `locator()` to find the coordinates of a mouse click

```R
# adds random noise to img, at the range rows,cols of img; img and the
# return value are both objects of class pixmap; the parameter q
# controls the weight of the noise, with the result being 1-q times the
# original image plus q times the random noise
blurpart <- function(img,rows,cols,q) {
lrows <- length(rows)
lcols <- length(cols)
newimg <- img
randomnoise <- matrix(nrow=lrows, ncol=ncols,runif(lrows*lcols))
newimg@grey <- (1-q) * img@grey + q * randomnoise
return(newimg)
}
```


## Filtering on Matrices

- Filtering can be done with matrices, like vectors

```R
> x
x
[1,] 1 2
[2,] 2 3
[3,] 3 4
> x[x[,2] >= 3,]
x
[1,] 2 3
[2,] 3 4
```


- Computation if completely vectorized operation
	- The object x[,2] is a vector
	- The operator >= compares two vectors
	- The number 3 was recycled to a vector of 3s


```R
> z <- c(5,12,13)
> x[z %% 2 == 1,]
[,1] [,2]
[1,] 1 4
[2,] 3 6
```

```R
> m
[,1] [,2]
[1,] 1 4
[2,] 2 5
[3,] 3 6
> m[m[,1] > 1 & m[,2] > 5,]
[1] 3 6
```

- The result of the filtering is a two-element vector, not a matrix
- Use `drop()` to tell R to retain the 2D data

```R
> m
[,1] [,2]
[1,] 5 -1
[2,] 2 10
[3,] 9 11
> which(m > 2)
[1] 1 3 5 6
```

- R returns the vector-indexing point of view
- Elements 1, 3, 5, and 6 of m are larger than 2

## Extended Example: Generating a Covariance Matrix

- Working with a n-variate normal distribution, the matrix will have n rows and n columns
- Each of the n variables have variance of 1, with correlation `rho` between pair of variables

![](Pasted%20image%2020250619235119.png)

Covariance matrix
- A square matrix that shows the covariance (two random variables) between each pair of elements in a multivariate dataset
- The œÅ (rho) values, also known as the Pearson correlation coefficients, represent the strength and direction of a linear relationship between pairs of variables


```R
makecov <- function(rho,n) {
2 m <- matrix(nrow=n,ncol=n)
3 m <- ifelse(row(m) == col(m),1,rho)
4 return(m)
5 }
```

```R
> z
[,1] [,2]
[1,] 3 6
[2,] 4 7
[3,] 5 8
> row(z)
[,1] [,2]
[1,] 1 1
[2,] 2 2
[3,] 3 3
```

- The `row() == col()` expression return TRUE and FALSE values
- TRUE on the diagonal, and FALSE elsewhere
- `ifelse(row(m) == col(m),1,rho)`
- This argument checks whether the matrix is square, and replaces and 1 and rho values


# 3.3 - Applying Functions to Matrix Rows and Columns

- `*apply()` functions
	- `apply()`
	- `tapply()`
	- `lapply()`

## Using the apply() Function

- General form of `apply` for matrices

`apply(m,dimcode,f,fargs)`

- `m` is the matrix
- `dimcode` is the dimension, equal to 1 if the function applies to rows or 2 for columns
- `f` is the function applied
- `fargs` is an optional set of arguments for `f`

```R
> z
[,1] [,2]
[1,] 1 4
[2,] 2 5
[3,] 3 6
> apply(z,2,mean)
[1] 2 5
```

```R
> z
[,1] [,2]
[1,] 1 4
[2,] 2 5
[3,] 3 6
> f <- function(x) x/c(2,8)
> y <- apply(z,1,f)
> y
[,1] [,2] [,3]
[1,] 0.5 1.000 1.50
[2,] 0.5 0.625 0.75
```

- The `f()` function divides a two-elee

## Extended Example: Finding Outliers
# 3.4 - Adding and Deleting Matrix Rows and Columns

## Changing the Size of a Matrix
## Extended Example: Finding the Closest Pair of Vertices in a Graph
# 3.5 - More on the Vector/Matrix Distinction
# 3.6 - Avoiding Unintended Dimension Reduction
# 3.7 - Naming Matrix Rows and Columns
# 3.8 - Higher-Dimensional Arrays
