**Recycling** - the automatic lengthening of vectors in certain settings
**Filtering** - The extraction of subsets of vectors
**Vectorization** - Where functions are applied element-wise to vectors

# 2.1 - Scalars, Vectors, Arrays, and Matrices

- In many programming languages, vector variables are different from _scalar_
- In R, numbers are considered one-element vectors, and there are not scalars
- R variables types are called modes

Modes
- Integer
- Numeric (floating-point)
- Character (string)
- Logical (boolean)
- Complex

- Use `typeof()` to check the mode variable

- Vector indices in R begin at 1


## Adding and Deleting Vector Elements

- Vectors are stores like arrays in C, contiguously
- Therefore cannot insert or delete elements
- Size of a vector is determined at its creation

```R
x <- c(88,5,12,13)
x <- c(x[1:3],168,x[4])
x
[1] 88 5 12 168 13
```

- This creates a new five-element vector, leaving x intact
- A new vector is created and stores the vector x in a different position
- Functional programming may restrict the potential for fast performance in R

## Obtaining the Length of a Vector

- Use `length()` to obtain the length of a vector

```R
x <- c(1,2,4)
length(x)
[1] 3
```

```R
first1 <- function(x){
	for (i in 1:length(x)){
		if (x[i] == 1) break
	}
	return(i)
}
```

- Writing `for (n in x)` will not work
- When null vector, the length is 0, and then when called again 1
- `seq()` is used instead

## Matrices and Array as Vectors


- Arrays and matrices are vectors
- They have class attributes
- Matrices have the number of rows and columns

```R
> m
[,1] [,2]
[1,] 1 2
[2,] 3 4

> m + 10:13
[,1] [,2]
[1,] 11 14
[2,] 14 17
```

# 2.2 - Declarations

- Compiled languages require that you declare variables
- With R, your do not declare variables
- If you reference specific elements of a vector, you must warn R

- To create a two-component vector, initialized variable to mode

```R
y <- vector(lengt=2)
y[1] <- 5
y[2] <- 12
y <- c(5,12) # will also work
```

- The right-hand side is creating a new vector to bind to y
- The reading and writing of individual vector elements are handled by function
- If R does not know that y is a vector, function have nothing on which to act
- Binding is not constrained in terms of mode

```R
x <- c(1,5)
x
[1] 1 5
x <- "abc"
```

# 2.3 - Recycling

- When applying an operation to two vectors that require the same length, R automatically recycles, or repeats, the shorter one

```R
c(1,2,4) + c(6,0,9,20,22)
[1] 7 2 13 21 24
```

- The shorter vector is recycles
- Matrices are long vectors

# 2.4 - Common Vector Operations

- Arithmetic
- Logical
- Vector indexing

## Vector Arithmetic and Logical Operations

- R is a functional language
- Every operator is a function

```R
> 2+3
[1] 5
> "+"(2,3)
[1] 5
```

- Scalars are one-element vectors
- Operations will be applied element-wise

```R
> x <- c(1,2,4)
> x + c(5,0,-1)
[1] 6 2 3
> x * c(5,0,-1)
[1] 5 0 -4
> x <- c(1,2,4)
> x / c(5,4,-1)
[1] 0.2 0.5 -4.0
> x %% c(5,4,-1)
[1] 1 2 0
```

- Multiplication is done element-wise

## Vector Indexing

- Indexing vectors forms a subvector by picking elements of the given vector for specific indices


```R
> y <- c(1.2,3.9,0.4,0.12)
> y[c(1,3)] # extract elements 1 and 3 of y
[1] 1.2 0.4
> y[2:3]
[1] 3.9 0.4
> v <- 3:4
> y[v]
[1] 0.40 0.12
```

- Negative subscript means that we want to exclude the given elements in our output

```R
> z <- c(5,12,13)
> z[-1] # exclude element 1
[1] 12 13
> z[-1:-2] # exclude elements 1 through 2
[1] 13
```

- To pick up all the elements

```R
> z[-length(z)]
[1] 5 12
```

## Generating Useful Vectors with the : Operator

- Colon operator produces a vector consisting of a range of numbers

```R
> 5:8
[1] 5 6 7 8
> 5:1
[1] 5 4 3 2 1
```


- Precedence issues

```R
> i <- 2
> 1:i-1 # this means (1:i) - 1, not 1:(i-1)
[1] 0 1
> 1:(i-1)
[1] 1
```


## Generating Vector Sequences with seq()

- The `seq()` function, generates a sequence in arithmetic progression
- Can separate by intervals

```R
> seq(from=12,to=30,by=3)
[1] 12 15 18 21 24 27 30
> seq(from=1.1,to=2,length=10)
[1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0
```

- `seq()` also deals with the empty-vector problem

`1:length(x)` evaluates to (1,0), when x is NULL
- use `for (i in seq(x))` instead to correctly evaluate to NULL

```R
> x <- c(5,12,13)
> x
[1] 5 12 13
> seq(x)
[1] 1 2 3
> x <- NULL
> x
NULL
> seq(x)
integer(0)
```



## Repeating Vector Constants with rep()

- Allows to conveniently put the same constraint into long vectors
- `rep(x,times)`, creates a vector of `times*length(x)` elements, that `times` copies of x

```R
> x <- rep(8,4)
> x
[1] 8 8 8 8
> rep(c(5,12,13),3)
[1] 5 12 13 5 12 13 5 12 13
> rep(1:3,2)
[1] 1 2 3 1 2 3
```

- To interleave copies of x

```R
> rep(c(5,12,13),each=2)
[1] 5 5 12 12 13 13
```

# 2.5 - Using all() and any()

- The `any()` and `all()` functions report whether any or all of their arguments are TRUE

```R
> x <- 1:10
> any(x > 8)
[1] TRUE
> any(x > 88)
[1] FALSE
> all(x > 88)
[1] FALSE
> all(x > 0)
[1] TRUE
```

## Extended Example: Finding Runs of Consecutive Ones

- `findruns()` determines length of the runs of 1s

```R
findruns <- function(x,k){
	n <- length(x)
	run <- NULL
	for (i in 1:(n-k+1)){
	if (all(x[i:(i+k-1)] == 1)) runs <= c(runs,i)
	}
	return(runs)
}
```

- `x[i:(i+k-1)]` is the range

```R
> y <- c(1,0,0,1,1,1,0,1,1)
> findruns(y,3)
[1] 4
> findruns(y,2)
[1] 4 5 8
> findruns(y,6)
NULL
```

- The buildup of vector runs is not good
- Vector allocation is time consuming
- Each execution of the following slows down code, as it allocate a new vector in the call c(runs, i)
- An alternative is to preallocate the memory space

```R
findruns1 <- function(x,k) {
	n <- length(x)
	runs <- vector(length=n)
	count <- 0
	for (i in 1:(n-k+1)) {
		if (all(x[i:(i+k-1)]==1)) {
			count <- count + 1
			runs[count] <- i
			}
		}
	if (count > 0) {
		runs <- runs[1:count]
	} else runs <- NULL
	return(runs)
}
```

- The above example reduces the number of memory allocation to two

## Extended Example: Predicting Discrete-Valued Time Series

- Majority rule
	- If the number of 1s in the previous k time period is at least k/2, the prediction of the next value is 1, otherwise 0
	- If k = 3, and data for the last three periods is 1, 0, 1, then the next period is 1
	- A common solution is to take known data, _training set_, and then ask how well various values of k would have performed on that data

- 500 days of data, and use k = 3
- To assess the predictive ability of that value for k, we "predict" each day in our data from the previous three days and then compare the prediction with the known values
- The results will produce an errors rate for k = 3
- Repeat for k = 1, 2, 3, 4, ...
- Use the k values, with the lowest error values to train data for future predictions

```R
preda <- function(x,k){
	n <- length(x)
	k2 <- k/2
	# vector pred contain predicted values
	pred <- vector(length=n-k)
	for (i in 1:(n-k)){
	if (sum(x[i:(i+(k-1))]) >= k2) pred[i] <- else pred[i] <- 0
	}
	return(mean{abs(pred-x[(k+1):n])})
}
```

- Line 7
	- Predicts day i+k from the k days previous to its
- `Pred` has the predicated values, with `x[(k+1):n]` has the actual values
- Use `mean()`, to find the proportion of 1s
- Rewrite code to take advantage of previous computation
- In each iteration, update previous sum, instead of calculating at the end

```R
predb <- function(x,k) {
2 n <- length(x)
3 k2 <- k/2
4 pred <- vector(length=n-k)
5 sm <- sum(x[1:k])
6 if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
7 if (n-k >= 2) {
8 for (i in 2:(n-k)) {
9 sm <- sm + x[i+k-1] - x[i-1]
10 if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
11 }
12 }
13 return(mean(abs(pred-x[(k+1):n])))
14 }
```


# 2.6 - Vectorized Operations

- Vectorized, meaning a function applied to a vector is actutally applied individually to each element

```R
> u <- c(5,2,8)
> v <- c(1,3,9)
> u > v
[1] TRUE FALSE FALSE
```

- \*, +, and > are examples of vectorized functions
- If R functions uses vectorized operations, then it too, is vectorized

```R
w <- function(x) return(x+1)
> w(u)
[1] 6 3 9
```

- Even transcendental functions (square roots, logs, trig functions) are vectorized

```R
> y <- c(1.2,3.9,0.4)
> z <- round(y)
> z
[1] 1 4 0
```

- Vectorized functions that appear to have scalar arguments

```R
> f
function(x,c) return((x+c)^2)
> f(1:3,0)
[1] 1 4 9
> f(1:3,1)
[1] 4 9 16
```

- There is nothing in f() that keep from an explicit vector for c

```R
> f(1:3,1:3)
[1] 4 16 36
```

- To restrict c to scalar, insert some kind of check

```R
> f
function(x,c) {
if (length(c) != 1) stop("vector c not allowed")
	return((x+c)^2)
}
```

## Vector In, Vector Out/Matrix Out

- A function that is vector-valued, with return a vector
- To return a matrix `matrix(z12(x),ncol=2)`
- To steamline use `sapply()`, or simplify apply, which converts the result to a matrix

```R
> z12 <- function(z) return(c(z,z^2))
> sapply(1:8,z12)
[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,] 1 2 3 4 5 6 7 8
[2,] 1 4 9 16 25 36 49 64
```


# 2.7 - NA and NULL Values

- "No such animal" values, such as None or undefined
- R has two types: NA and NULL
- Missing/unknown data is represented with NA
- NULL, represent that the value does not exist

## Using NA

```R
> x <- c(88,NA,12,168,13)
> x
[1] 88 NA 12 168 13
> mean(x)
[1] NA
> mean(x,na.rm=T)
[1] 70.25
> x <- c(88,NULL,12,168,13)
> mean(x)
[1] 70.25
```

- `mean()` refused to calculate, as one value in x was NA
- Setting the optional argument `na.rm` (NA remove) to true, calculate the mean of the remaining elements
- R will auto skip over the NULL value

## Using NULL

- One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector

```R
# build up a vector of the even numbers in 1:10
> z <- NULL
> for (i in 1:10) if (i %%2 == 0) z <- c(z,i)
> z
[1] 2 4 6 8 10
```

# 2.8 - Filtering

## Generating Filtering Indices
## Filtering with the subset() Function
## The Selection Function which()
# 2.9 - A Vectorized if-then-else

## Extended Example: A Measure of Association

## Extended Example: Recoding on Abalone Data Set

# 2.10 - Testing Vector Equality
# 2.11 - Vector Element Names
# 2.12 - More on c()